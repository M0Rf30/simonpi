#!/usr/bin/env bash
# This script was generated by bashly 1.0.0 (https://bashly.dannyb.co)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if [[ "${BASH_VERSINFO:-0}" -lt 4 ]]; then
  printf "bash version 4 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
simonpi_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi - A Swiss Army knife to emulate Raspberry PI family devices on your laptop.\n"
    echo

  else
    printf "simonpi - A Swiss Army knife to emulate Raspberry PI family devices on your laptop.\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi COMMAND\n"
  printf "  simonpi [COMMAND] --help | -h\n"
  printf "  simonpi --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Generate bash completions\n" "completions"
  printf "  %s   Check filesystem integrity of disk image\n" "check      "
  printf "  %s   Purge everything in storage folder\n" "epurge     "
  printf "  %s   Download latest available kernel for your target\n" "kernel     "
  printf "  %s   Kill every instance and network virtual interface\n" "kill       "
  printf "  %s   List files in storage folder\n" "list       "
  printf "  %s   Mount boot and root partitions\n" "mount      "
  printf "  %s   Purge everything except for downloaded archives\n" "purge      "
  printf "  %s   Run QEMU processor emulator for defined model\n" "run        "
  printf "  %s   Unmount boot and root partitions\n" "umount     "
  printf "  %s   Write a partitioned raw image disk with Arch Linux\n" "write      "
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "STORAGE (required)"
    printf "    Set your storage home path\n"
    printf "    Default: ${HOME}/.simonpi\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "KERNEL_PATH (required)"
    printf "    Set the kernel home path\n"
    printf "    Default: ./data/kernels\n"
    echo

  fi
}

# :command.usage
simonpi_completions_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi completions\n"
    echo

    printf "  Generate bash completions\n  Usage: eval \"\$(simonpi completions)\"\n"
    echo

  else
    printf "simonpi completions - Generate bash completions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi completions\n"
  printf "  simonpi completions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
simonpi_check_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi check - Check filesystem integrity of disk image\n"
    echo

  else
    printf "simonpi check - Check filesystem integrity of disk image\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi check MODEL\n"
  printf "  simonpi check --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi c rpi\n"
    printf "  simonpi check rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_epurge_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi epurge - Purge everything in storage folder\n"
    echo

  else
    printf "simonpi epurge - Purge everything in storage folder\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi epurge MODEL\n"
  printf "  simonpi epurge --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi epurge rpi\n"
    printf "  simonpi e rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_kernel_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi kernel - Download latest available kernel for your target\n"
    echo

  else
    printf "simonpi kernel - Download latest available kernel for your target\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi kernel MODEL\n"
  printf "  simonpi kernel --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi kernel rpi\n"
    printf "  simonpi k rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_kill_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi kill - Kill every instance and network virtual interface\n"
    echo

  else
    printf "simonpi kill - Kill every instance and network virtual interface\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi kill MODEL\n"
  printf "  simonpi kill --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi kill rpi\n"
    printf "  simonpi k rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_list_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi list - List files in storage folder\n"
    echo

  else
    printf "simonpi list - List files in storage folder\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi list MODEL\n"
  printf "  simonpi list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi list rpi\n"
    printf "  simonpi l rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_mount_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi mount - Mount boot and root partitions\n"
    echo

  else
    printf "simonpi mount - Mount boot and root partitions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi mount MODEL\n"
  printf "  simonpi mount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi mount rpi\n"
    printf "  simonpi m rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_purge_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi purge - Purge everything except for downloaded archives\n"
    echo

  else
    printf "simonpi purge - Purge everything except for downloaded archives\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi purge MODEL\n"
  printf "  simonpi purge --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi purge rpi\n"
    printf "  simonpi p rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_run_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi run - Run QEMU processor emulator for defined model\n"
    echo

  else
    printf "simonpi run - Run QEMU processor emulator for defined model\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi run MODEL [OPTIONS]\n"
  printf "  simonpi run --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--path PATH"
    printf "    Path to Qemu disk image\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi run rpi\n"
    printf "  simonpi r rpi-4\n"
    printf "  simonpi run rpi --path my_image.img\n"
    printf "  simonpi r rpi-4 -p /home/simonpi/my_image.img\n"
    echo

  fi
}

# :command.usage
simonpi_umount_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi umount - Unmount boot and root partitions\n"
    echo

  else
    printf "simonpi umount - Unmount boot and root partitions\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi umount MODEL\n"
  printf "  simonpi umount --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi umount rpi\n"
    printf "  simonpi u rpi-4\n"
    echo

  fi
}

# :command.usage
simonpi_write_usage() {
  if [[ -n $long_usage ]]; then
    printf "simonpi write - Write a partitioned raw image disk with Arch Linux\n"
    echo

  else
    printf "simonpi write - Write a partitioned raw image disk with Arch Linux\n"
    echo

  fi

  printf "%s\n" "Usage:"
  printf "  simonpi write MODEL [OPTIONS]\n"
  printf "  simonpi write --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n $long_usage ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--size, -s SIZE (required)"
    printf "    QEMU disk image size in GB\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "MODEL"
    printf "    Raspberry Pi model (rpi, rpi-2, rpi-3, rpi-4)\n"
    echo

    # :command.usage_examples
    printf "%s\n" "Examples:"
    printf "  simonpi write rpi --size 4\n"
    printf "  simonpi w rpi-4 -s 4\n"
    echo

  fi
}

# :command.normalize_input
normalize_input() {
  local arg flags

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    else
      input+=("$arg")
    fi

    shift
  done
}
# :command.inspect_args
inspect_args() {
  readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
  if ((${#args[@]})); then
    echo args:
    for k in "${sorted_keys[@]}"; do echo "- \${args[$k]} = ${args[$k]}"; done
  else
    echo args: none
  fi

  if ((${#other_args[@]})); then
    echo
    echo other_args:
    echo "- \${other_args[*]} = ${other_args[*]}"
    for i in "${!other_args[@]}"; do
      echo "- \${other_args[$i]} = ${other_args[$i]}"
    done
  fi
}

# :command.user_lib
# src/lib/checks.sh
#!/usr/bin/env bash

# Must be root for some ops
check_root() {
  if [[ $(sudo whoami) != "root" ]]; then
    echo -e "[$(red_bold "FAILED")] Sim-on-Pi will not continue"
    echo -e "[$(red_bold "FAILED")] Please type your user password or run this script as root"
    exit 1
  fi
}

check_kernel() {
  if [[ ! -f "${STORAGE}/${args[model]}/kernel/image" ]]; then
    echo -e "[$(red_bold "FAILED")] Sim-on-Pi will not continue"
    echo -e "[$(cyan_bold " INFO ")] Please download an appropriate kernel with kernel command"
    exit 1
  fi
}

check_loop_devices() {
  local device2="${1}"
  if [[ ${device2##*/loop} -gt 5 ]]; then
    echo -e "[$(yellow_bold " WARN ")] You are using more than 3 instances"
  fi
}

check_docker() {
  local docker
  if [[ -f /.dockerenv ]]; then
    docker=1
    echo -e "[$(yellow_bold " WARN ")] In a Docker container ..."
  else
    docker=0
    echo -e "[$(yellow_bold " WARN ")] Out of a Docker container ..."
  fi
  echo "${docker}"
}

# src/lib/colors.sh
print_in_color() {
  local color="$1"
  shift
  if [[ -z ${NO_COLOR+x} ]]; then
    printf "$color%b\e[0m\n" "$*";
  else
    printf "%b\n" "$*";
  fi
}

red() { print_in_color "\e[31m" "$*"; }
green() { print_in_color "\e[32m" "$*"; }
yellow() { print_in_color "\e[33m" "$*"; }
blue() { print_in_color "\e[34m" "$*"; }
magenta() { print_in_color "\e[35m" "$*"; }
cyan() { print_in_color "\e[36m" "$*"; }
bold() { print_in_color "\e[1m" "$*"; }
underlined() { print_in_color "\e[4m" "$*"; }
red_bold() { print_in_color "\e[1;31m" "$*"; }
green_bold() { print_in_color "\e[1;32m" "$*"; }
yellow_bold() { print_in_color "\e[1;33m" "$*"; }
blue_bold() { print_in_color "\e[1;34m" "$*"; }
magenta_bold() { print_in_color "\e[1;35m" "$*"; }
cyan_bold() { print_in_color "\e[1;36m" "$*"; }
red_underlined() { print_in_color "\e[4;31m" "$*"; }
green_underlined() { print_in_color "\e[4;32m" "$*"; }
yellow_underlined() { print_in_color "\e[4;33m" "$*"; }
blue_underlined() { print_in_color "\e[4;34m" "$*"; }
magenta_underlined() { print_in_color "\e[4;35m" "$*"; }
cyan_underlined() { print_in_color "\e[4;36m" "$*"; }

# src/lib/config.sh
config_init() {
  CONFIG_FILE=${CONFIG_FILE:=config.ini}
  [[ -f "$CONFIG_FILE" ]] || touch "$CONFIG_FILE"
}

config_get() {
  local key=$1
  local regex="^$key *= *(.+)$"
  local value=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      value="${BASH_REMATCH[1]}"
      break
    fi
  done < "$CONFIG_FILE"

  echo "$value"
}

config_set() {
  local key=$1
  shift
  local value="$*"

  config_init

  local regex="^($key) *= *.+$"
  local output=""
  local found_key=""
  local newline

  while IFS= read -r line || [ -n "$line" ]; do
    newline=$line
    if [[ $line =~ $regex ]]; then
      found_key="${BASH_REMATCH[1]}"
      newline="$key = $value"
      output="$output$newline\n"
    elif [[ $line ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  if [[ -z $found_key ]]; then
    output="$output$key = $value\n"
  fi

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

config_del() {
  local key=$1

  local regex="^($key) *="
  local output=""

  config_init

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line ]] && [[ ! $line =~ $regex ]]; then
      output="$output$line\n"
    fi
  done < "$CONFIG_FILE"

  printf "%b\n" "$output" > "$CONFIG_FILE"
}

config_show() {
  config_init
  cat "$CONFIG_FILE"
}

config_keys() {
  local regex="^([a-zA-Z0-9_\-\/\.]+) *="

  config_init

  local keys=()
  local key

  while IFS= read -r line || [ -n "$line" ]; do
    if [[ $line =~ $regex ]]; then
      key="${BASH_REMATCH[1]}"
      keys+=("$key")
    fi
  done < "$CONFIG_FILE"
  echo "${keys[@]}"
}

config_has_key() {
  [[ $(config_get "$1") ]]
}

# src/lib/docker.sh
#!/usr/bin/env bash

check_docker() {
  if [[ -f /.dockerenv ]]; then
    echo -e "[$(yellow_bold " WARN ")] In a Docker container ..."
  else
    echo -e "[$(yellow_bold " WARN ")] Out of a Docker container ..."
  fi
}

# src/lib/images.sh
#!/usr/bin/env bash

integrity_check() {
  local arch_iso_md5="$1"

  cd "${STORAGE}/${args[model]}" || exit

  if md5sum --status -c "${arch_iso_md5}"; then
    echo -e "[$(green_bold "  OK  ")] Integrity check successfully completed"
  else
    echo -e "[$(red_bold "FAILED")] Integrity check failed, please retry to download"
    exit 1
  fi
}

download_arch_image() {
  local arch_iso_md5="$1"
  local files=("${arch_iso_md5}" "${arch_iso_md5%%.md5}")

  for i in "${files[@]}"; do
    echo -e "[$(cyan_bold " INFO ")] Downloading latest iso for ${args[model]}..."
    curl -# -L -C - "http://os.archlinuxarm.org/os/${i}" \
      -o "${STORAGE}/${args[model]}/${i}"
  done
}

download_kernel_image() {
  local kernel_image="qemu_kernel_${args[model]//-/_}"
  local files=("${arch_iso_md5}" "${arch_iso_md5%%.md5}")
  local version

  if [[ -f "${STORAGE}/${args[model]}/kernel/image" ]]; then
    rm "${STORAGE}/${args[model]}/kernel/image"
  fi

  if [[ ${args[model]#*-} -gt "3" ]]; then
    kernel_image="qemu_kernel_rpi_3"
  fi

  version="$(curl -L -s -H 'Accept: application/json' \
    https://github.com/M0Rf30/"${kernel_image//_/-}"/releases/latest |
    sed -e 's/.*"tag_name":"\([^"]*\)".*/\1/')"

  echo -e "[$(cyan_bold " INFO ")] Downloading latest kernel for ${args[model]}..."
  curl -# -L -C - \
    "https://github.com/M0Rf30/${kernel_image//_/-}/releases/download/${version}/${kernel_image}-${version}" \
    -o "${STORAGE}/${args[model]}/kernel/image"
}

partition_status() {
  local arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  local custom_sdcard_img="${args[--path]}"
  local part_mounted=0

  if [[ -n ${custom_sdcard_img} ]]; then
    arch_sdcard_img="${custom_sdcard_img}"
  fi

  if mount | grep "${STORAGE}/${args[model]}" >/dev/null; then
    part_mounted=1
  elif ! mount | grep "${STORAGE}/${args[model]}" >/dev/null &&
    [[ -n ${LOOPFLAG} ]]; then
    part_mounted=0
  elif [[ ! -f ${arch_sdcard_img} ]]; then
    part_mounted=2
  fi
  echo "${part_mounted}"
}

img_status() {
  local arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  local custom_sdcard_img="${args[--path]}"
  local img_mounted=0

  if [[ -n ${custom_sdcard_img} ]]; then
    arch_sdcard_img="${custom_sdcard_img}"
  fi

  if mount | grep "${STORAGE}/${args[model]}" >/dev/null; then
    img_mounted=1
  elif [[ ! -f ${arch_sdcard_img} ]]; then
    img_mounted=2
  fi
  echo "${img_mounted}"
}

mount_img() {
  local arch_sdcard_img="$1"
  local device1="$2"
  local device2="$3"

  local start1
  start1=$(fdisk -lo Start "${arch_sdcard_img}" | tail -n 2 | head -n -1)
  local start2
  start2=$(fdisk -lo Start "${arch_sdcard_img}" | tail -n 1)
  local length1
  length1=$(fdisk -lo Sectors "${arch_sdcard_img}" | tail -n 2 | head -n -1)
  local length2
  length2=$(fdisk -lo Sectors "${arch_sdcard_img}" | tail -n 1)

  echo -e "[$(green_bold "  OK  ")] Mounting disk image named ${arch_sdcard_img##*/} ..."
  sudo -E losetup -o $((start1 * 512)) --sizelimit $((length1 * 512)) \
    "${device1}" "${arch_sdcard_img}" >/dev/null 2>&1
  sudo -E losetup -o $((start2 * 512)) --sizelimit $((length2 * 512)) \
    "${device2}" "${arch_sdcard_img}" >/dev/null 2>&1
}

umount_img() {
  sudo -E losetup -D
  echo -e "[$(green_bold "  OK  ")] Unmounting disk image named ${arch_sdcard_img##*/} ..."
}

write_pflash_images() {
  if [ ! -f "${STORAGE}/${args[model]}/flash0.img" ]; then
    dd if=/dev/zero bs=1M count=64 of="${STORAGE}/flash0.img"
    dd if=/dev/zero bs=1M count=64 of="${STORAGE}/flash1.img"
    dd if=/usr/share/edk2-armvirt/aarch64/QEMU_CODE.fd \
      of="${STORAGE}/${args[model]}/flash0.img" bs=1M conv=notrunc
    dd if=/usr/share/edk2-armvirt/aarch64/QEMU_VARS.fd \
      of="${STORAGE}/${args[model]}/flash1.img" bs=1M conv=notrunc
  fi
}

run_custom_img() {
  local custom_img="$1"

  if [ ! -f "${custom_img}" ]; then
    echo -e "[$(red_bold "FAILED")] File not found"
    exit 1
  elif [ "$(file "${custom_img}" | cut -d ' ' -f 2)" != "DOS/MBR" ]; then
    echo -e "[$(red_bold "FAILED")] Please specify a valid disk image"
    exit 1
  else
    echo -e "[$(green_bold "  OK  ")] Running with disk image named ${custom_img##*/}"
  fi
}

# src/lib/network.sh
#!/usr/bin/env bash

generate_mac() {
  # Generate Random MAC ADDRESS to avoid collisions
  printf "52:54:%02x:%02x:%02x:%02x" $((RANDOM & 0xff)) $((RANDOM & 0xff)) $((RANDOM & 0xff)) $((RANDOM & 0xff))
}

get_internet_if() {
  iface=$(ip route | grep default | sed -e "s/^.*dev.//" -e "s/.proto.*//")
  echo "${iface}"
}

check_tap() {
  local tap_if="$1"
  if [[ -d "/sys/class/net/${tap_if}" ]]; then
    while [[ -d "/sys/class/net/${tap_if}" ]]; do
      TAPON=1
      tap_if=rasp-tap$((${tap_if##rasp-tap} + 1))
    done
  else
    TAPON=0
  fi
}

check_dnsmasq() {
  local gateway_ip="$1"
  pgrep -f "${gateway_ip}"
}

setup_dnsmasq() {
  local nameservers
  local searchdomains
  local gateway_ip="$1"
  local first_ip="$2"
  local last_ip="$3"
  local bridge_if="$4"

  DNSMASQ_OPTS="--listen-address=${gateway_ip} --interface=${bridge_if} \
    --bind-interfaces --dhcp-range=${first_ip},${last_ip}"

  # Build DNS options from container /etc/resolv.conf
  mapfile -t nameservers < <(grep nameserver /etc/resolv.conf |
    head -n 2 | sed 's/nameserver //')
  mapfile -t searchdomains < <(grep search /etc/resolv.conf |
    sed 's/search //' | sed 's/ /,/g')

  domainname=$(echo "${searchdomains[@]}" | awk -F"," '{print $1}')

  if [[ -n ${domainname} ]]; then
    DNSMASQ_OPTS+=" --dhcp-option=option:domain-name,${domainname}"
  fi

  for nameserver in "${nameservers[@]}"; do
    [[ -z ${DNS_SERVERS} ]] &&
      DNS_SERVERS=${nameserver} ||
      DNS_SERVERS="${DNS_SERVERS},${nameserver}"
  done

  if [[ -z ${DNSMASQPID} ]] &&
    ! ss -ntl | grep -q :53; then
    echo -e "[$(green_bold "  OK  ")] Turning up dnsmasq for guest IP assignment ..."
    DNSMASQ_OPTS+=" --dhcp-option=option:dns-server,${DNS_SERVERS} --dhcp-option=option:router,${GATEWAY}"
    eval "sudo -E ${DNSMASQ} ${DNSMASQ_OPTS}"
    echo -e "[$(green_bold "  OK  ")] Gateway address: ${gateway_ip}"

  elif [[ -z ${DNSMASQPID} ]] && ss -ntl | grep -q :53; then
    echo -e "[$(yellow_bold " WARN ")] Port 53 is busy"
    echo -e "[$(yellow_bold " WARN ")] Trying to use local dns service ( maybe offline )"
    DNSMASQ_OPTS="${DNSMASQ_OPTS} --dhcp-option=option:dns-server,127.0.0.1 --port=0"
    eval "sudo -E ${DNSMASQ} ${DNSMASQ_OPTS}"
  else
    echo -e "[$(yellow_bold " WARN ")] Another instance of ${DNSMASQ} is running ..."
  fi
}

kill_dnsmasq() {
  local dnsmasq_pid="$1"
  if [[ -n ${dnsmasq_pid} ]]; then
    sudo -E kill -9 "${dnsmasq_pid}"
  fi
}

shutdown_network() {
  local bridge_if="$1"
  local tap_if="$2"

  echo -e "[$(green_bold "  OK  ")] Shutting down present network for QEMU ..."
  while [[ -d "/sys/class/net/${bridge_if}" ]] ||
    [[ -d "/sys/class/net/${tap_if}" ]]; do
    sudo -E ip link set "${tap_if}" nomaster >/dev/null 2>&1          # Enslave tap
    sudo -E ip tuntap del dev "${tap_if}" mode tap >/dev/null 2>&1    # Remove tap
    sudo -E ip link delete "${bridge_if}" type bridge >/dev/null 2>&1 # Remove bridge
    sudo -E su -c "echo 0 > /proc/sys/net/ipv4/ip_forward"
  done
}

force_shutdown_network() {
  local bridge_if="$1"
  echo -e "[$(green_bold "  OK  ")] Forced network shutdown for QEMU ..."

  while [[ -d "/sys/class/net/${bridge_if}" ]] ||
    [[ -n "$(find /sys/class/net/ -name "rasp*")" ]]; do
    for i in /sys/class/net/rasp-tap*; do
      # Enslave tap
      sudo -E ip link set "${i##*/}" nomaster >/dev/null 2>&1
      # Remove tap
      sudo -E ip tuntap del dev "${i##*/}" mode tap >/dev/null 2>&1
    done
    # Remove bridge
    sudo -E ip link delete "${bridge_if}" type bridge >/dev/null 2>&1
  done
}

bridge_up() {
  # Add bridge
  sudo -E ip link add "${bridge_if}" type bridge
  # Set ip to bridge interface
  sudo -E ip addr add "${gateway_ip}"/24 broadcast "${broadcast_ip}" dev "${bridge_if}"
  sudo -E ip link set "${bridge_if}" up

  sleep 0.5s
}

setup_nat() {
  iface=$(getInternetIf)
  sudo -E iptables -t nat -A POSTROUTING -o "${iface}" -j MASQUERADE
  sudo -E iptables -A FORWARD -m conntrack \
    --ctstate RELATED,ESTABLISHED -j ACCEPT
  sudo -E iptables -A FORWARD -i "${tap_if}" -o "${iface}" -j ACCEPT
}

setup_tap() {
  local tap_if="$1"

  # Add tap interface
  sudo -E ip tuntap add dev "${tap_if}" mode tap user "$(checkUser)"
  sudo -E ip link set "${tap_if}" up promisc on

  sleep 0.5s
  # Bind tap to bridge
  sudo -E ip link set "${tap_if}" master "${bridge_if}"
}

create_network() {
  local tap_if="$1"
  local bridge_if="$2"
  local gateway_ip="$3"
  local broadcast_ip="$4"

  check_tap "${tap_if}"

  echo -e "[$(green_bold "  OK  ")] Turning up a network for QEMU ..."
  if [[ ${IPFORWARD} != "1" ]]; then
    sudo -E su -c "echo 1 > /proc/sys/net/ipv4/ip_forward"
  fi

  if [[ ${TAPON} -eq 0 ]]; then
    bridge_up "${bridge_if}" "${gateway_ip}" "${broadcast_ip}"
  fi

  setup_tap "${tap_if}" "${bridge_if}"
}

# src/lib/qemu.sh
#!/usr/bin/env bash

export QEMU_AUDIO_DRV=none

check_qemu() {
  local qemu
  if [[ -n "$(pidof "qemu-system-arm")" ]] ||
    [[ -n "$(pidof "qemu-system-aarch64")" ]]; then
    qemu=1
  else
    qemu=0
  fi
  echo "${qemu}"
}

kill_qemu() {
  local qemu="$1"

  if [[ ${qemu} == "1" ]]; then
    echo -e "[$(green_bold "  OK  ")] Killing QEMU instances ..."
    if [[ -n "$(pidof "qemu-system-arm")" ]]; then
      for i in $(pidof "qemu-system-arm"); do
        sudo -E kill -15 "${i}"
      done
    else
      for i in $(pidof "qemu-system-aarch64"); do
        sudo -E kill -15 "${i}"
      done
    fi
  else
    echo -e "[$(cyan_bold " INFO ")] QEMU is not running ..."
  fi
}

# src/lib/run_emu.sh
#!/usr/bin/env bash

run_rpi() {
  local arch_sdcard_img="$1"
  local cmd_line_network="$2"

  local qemu_rpi="qemu-system-arm \
    -nographic \
    -cpu arm1176 \
    -m 256 \
    -M versatilepb \
    -drive file=${arch_sdcard_img},if=scsi,format=raw,cache=none \
    -kernel ${STORAGE}/${args[model]}/kernel \
    -no-reboot \
    -append \"root=/dev/sda2 fstab=no rootfstype=ext4 rw console=ttyAMA0 quiet audit=0 panic=1\""

  qemu_rpi+="${cmd_line_network}"
  eval "${qemu_rpi}"
}

run_rpi-2() {
  local arch_sdcard_img="$1"
  local cmd_line_network="$2"

  local qemu_rpi2="qemu-system-arm \
    -nographic \
    -cpu cortex-a15 \
    -m 1024 \
    -M virt \
    -drive file=fat:rw:${STORAGE}/${args[model]}/kernel,if=none,format=raw,cache=none,id=hd0 \
    -device virtio-blk-device,drive=hd0,bootindex=0 \
    -drive file=${arch_sdcard_img},if=none,format=raw,cache=writeback,id=hd1 \
    -device virtio-blk-device,drive=hd1,bootindex=1 \
    -drive file=/usr/share/edk2-armvirt/arm/QEMU_CODE.fd,if=pflash,format=raw,readonly=on \
    -drive file=/usr/share/edk2-armvirt/arm/QEMU_VARS.fd,if=pflash,format=raw \
    -kernel ${STORAGE}/${args[model]}/kernel/image \
    -append \"root=/dev/vda2 rootfstype=ext4 rw audit=0 console=ttyAMA0\""

  qemu_rpi2+=${cmd_line_network}
  eval "${qemu_rpi2}"
}

run_rpi-3() {
  local arch_sdcard_img="$1"
  local cmd_line_network="$2"

  local qemu_rpi3="qemu-system-aarch64 \
    -nographic \
    -machine virt-5.0,accel=tcg,gic-version=3 \
    -cpu cortex-a57 \
    -m 2048 \
    -drive file=fat:rw:${STORAGE}/${args[model]}/kernel,if=none,format=raw,cache=none,id=hd0 \
    -device virtio-blk-device,drive=hd0,bootindex=0 \
    -drive file=${arch_sdcard_img},if=none,format=raw,cache=writeback,id=hd1 \
    -device virtio-blk-device,drive=hd1,bootindex=1 \
    -drive file=/usr/share/edk2-armvirt/aarch64/QEMU_CODE.fd,if=pflash,format=raw,readonly=on \
    -drive file=/usr/share/edk2-armvirt/aarch64/QEMU_VARS.fd,if=pflash,format=raw \
    -kernel ${STORAGE}/${args[model]}/kernel/image \
    -append \"root=/dev/vda2 rootfstype=ext4 rw audit=0 console=ttyAMA0\""

  qemu_rpi3+=${cmd_line_network}
  eval "${qemu_rpi3}"
}

run_rpi-4() {
  local arch_sdcard_img="$1"
  local cmd_line_network="$2"

  local qemu_rpi4="qemu-system-aarch64 \
    -nographic \
    -machine virt-5.0,accel=tcg,gic-version=3 \
    -cpu cortex-a57 \
    -m 2048 \
    -drive file=fat:rw:${STORAGE}/${args[model]}/kernel,if=none,format=raw,cache=none,id=hd0 \
    -device virtio-blk-device,drive=hd0,bootindex=0 \
    -drive file=${arch_sdcard_img},if=none,format=raw,cache=writeback,id=hd1 \
    -device virtio-blk-device,drive=hd1,bootindex=1 \
    -drive file=/usr/share/edk2-armvirt/aarch64/QEMU_CODE.fd,if=pflash,format=raw,readonly=on \
    -drive file=/usr/share/edk2-armvirt/aarch64/QEMU_VARS.fd,if=pflash,format=raw \
    -kernel ${STORAGE}/${args[model]}/kernel/image \
    -append \"root=/dev/vda2 rootfstype=ext4 rw audit=0 console=ttyAMA0\""

  qemu_rpi4+=${cmd_line_network}
  eval "${qemu_rpi4}"
}

# src/lib/send_completions.sh
send_completions() {
  echo $'#!/usr/bin/env bash'
  echo $''
  echo $'# This bash completions script was generated by'
  echo $'# completely (https://github.com/dannyben/completely)'
  echo $'# Modifying it manually is not recommended'
  echo $'_simonpi_completions() {'
  echo $'  local cur=${COMP_WORDS[COMP_CWORD]}'
  echo $'  local comp_line="${COMP_WORDS[@]:1}"'
  echo $''
  echo $'  case "$comp_line" in'
  echo $'    \'completions\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'epurge\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'kernel\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'umount\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'check\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'mount\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'purge\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'write\'*) COMPREPLY=($(compgen -W "--help --size -h -s" -- "$cur")) ;;'
  echo $'    \'kill\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'list\'*) COMPREPLY=($(compgen -W "--help -h" -- "$cur")) ;;'
  echo $'    \'run\'*) COMPREPLY=($(compgen -W "--help --path -h -p" -- "$cur")) ;;'
  echo $'    \'\'*) COMPREPLY=($(compgen -W "--help --version -h -v check completions epurge kernel kill list mount purge run umount write" -- "$cur")) ;;'
  echo $'  esac'
  echo $'}'
  echo $''
  echo $'complete -F _simonpi_completions simonpi'
}

# src/lib/storage.sh
#!/usr/bin/env bash

check_storage() {
  local required_folders=("boot" "kernel" "root")

  for i in "${required_folders[@]}"; do
    if [[ -d "${STORAGE}/${args[model]}/${i}" ]]; then
      echo -e "[$(yellow_bold " WARN ")] ${args[model]}/${i} folder is present"
    else
      echo -e "[$(green_bold "  OK  ")] Creating ${args[model]}/${i} folder ..."
      mkdir -p "${STORAGE}/${args[model]}/${i}"
      chown -R "${USER}:${USER}" "${STORAGE}/${args[model]}/${i}"
    fi
  done
}

list_storage() {
  echo -e "[$(cyan_bold " INFO ")] Content of ${STORAGE}/${args[model]}"
  cyan_bold "$(ls -la "${STORAGE}/${args[model]}")"
}

check_fs() {
  local device1="$1"
  local device2="$2"
  echo -e "[$(green_bold "  OK  ")] Checking partitions to prevent failures ..."
  sudo -E fsck.vfat -f "${device1}"
  sudo -E fsck.ext4 -f "${device2}"
}

purge_storage() {
  local arch_sdcard_img="$1"
  local istatus="$2"

  if [[ ${istatus} != "2" ]]; then
    echo -e "[$(green_bold "  OK  ")] Soft cleaning ..."
    rm -rf "${arch_sdcard_img}"
    rm -rf "${STORAGE:?}/${args[model]}/kernel/image"
  fi
}

purge_storage_e() {
  echo -e "[$(green_bold "  OK  ")] Hard cleaning ..."
  rm -rf "${STORAGE:?}/${args[model]}/"
}

format_lo_devices() {
  local arch_sdcard_img="$1"
  local device1="$2"
  local device2="$3"

  echo -e "[$(green_bold "  OK  ")] Creating partitions on disk image named ${arch_sdcard_img##*/} ..."
  sudo -E mkfs.vfat -n boot -F 32 "${device1}" >/dev/null 2>&1
  sudo -E mkfs.ext4 -L rootfs "${device2}" >/dev/null 2>&1
}

mount_partitions() {
  local arch_sdcard_img="$1"
  local device1="$2"
  local device2="$3"
  local boot_path="$4"
  local root_path="$5"

  echo -e "[$(green_bold "  OK  ")] Mounting partitions of ${arch_sdcard_img##*/} ..."
  sudo -E mount "${device1}" "${boot_path}"
  sudo -E mount "${device2}" "${root_path}"
}

umount_partitions() {
  local arch_sdcard_img="$1"
  local boot_path="$2"
  local root_path="$3"
  echo -e "[$(green_bold "  OK  ")] Umounting partitions of ${arch_sdcard_img##*/} ..."
  sudo -E umount "${boot_path}"
  sudo -E umount "${root_path}"
}

# :command.command_functions
# :command.function
simonpi_completions_command() {
  # src/completions_command.sh
  #!/usr/bin/env bash

  # Call the `send_completions` function which was added by running:
  #
  #   $ bashly add comp function
  #
  # Users can now enable bash completion for this script by running:
  #
  #   $ eval "$(cli completions)"
  #
  send_completions

}

# :command.function
simonpi_check_command() {
  # src/check_command.sh
  #!/usr/bin/env bash

  device1=$(sudo -E losetup -f)
  device2=/dev/loop$((${device1##*/loop} + 1))

  check_fs "${device1}" "${device2}"

}

# :command.function
simonpi_epurge_command() {
  # src/epurge_command.sh
  #!/usr/bin/env bash

  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  istatus="$(img_status)"
  pstatus="$(partition_status)"
  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"

  if [[ ${istatus} == "1" ]] && [[ ${pstatus} == "0" ]]; then
    check_root
    umount_img
  elif [[ ${pstatus} == "1" ]]; then
    check_root
    umount_partitions "${arch_sdcard_img}" "${boot_path}" "${root_path}"
    umount_img
  fi

  purge_storage "${arch_sdcard_img}" "${istatus}"
  purge_storage_e "${arch_sdcard_img}" "${istatus}"

}

# :command.function
simonpi_kernel_command() {
  # src/kernel_command.sh
  #!/usr/bin/env bash

  check_storage
  download_kernel_image

}

# :command.function
simonpi_kill_command() {
  # src/kill_command.sh
  #!/usr/bin/env bash
  gateway_ip="192.168.66.1"
  bridge_if="rasp-br0"

  qemu_status="$(check_qemu)"
  check_root
  kill_qemu "${qemu_status}"
  dnsmasq_pid=$(check_dnsmasq "${gateway_ip}")
  kill_dnsmasq "${dnsmasq_pid}"
  force_shutdown_network "${bridge_if}"

}

# :command.function
simonpi_list_command() {
  # src/list_command.sh
  #!/usr/bin/env bash

  echo "# this file is located in 'src/list_command.sh'"
  echo "# code for 'simonpi list' goes here"
  echo "# you can edit it freely and regenerate (it will not be overwritten)"
  check_storage
  list_storage

}

# :command.function
simonpi_mount_command() {
  # src/mount_command.sh
  #!/usr/bin/env bash

  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  istatus="$(img_status)"
  pstatus="$(partition_status)"
  device1=$(sudo -E losetup -f)
  device2=/dev/loop$((${device1##*/loop} + 1))
  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"

  if [[ ${istatus} == "0" ]] && [[ ${pstatus} == "0" ]]; then
  	check_root
  	check_loop_devices "${device2}"
  	mount_img "${arch_sdcard_img}" "${device1}" "${device2}"
  	check_fs "${device1}" "${device2}"
  	check_storage
  	mount_partitions "${arch_sdcard_img}" "${device1}" "${device2}" "${boot_path}" "${root_path}"
  elif [[ ${istatus} == "1" ]] && [[ ${pstatus} == "0" ]]; then
  	check_root
  	check_loop_devices "${device2}"
  	check_fs "${device1}" "${device2}"
  	check_storage
  	mount_partitions "${arch_sdcard_img}" "${device1}" "${device2}" "${boot_path}" "${root_path}"
  elif [[ ${pstatus} == "1" ]]; then
  	return
  else
  	exit 1
  fi

}

# :command.function
simonpi_purge_command() {
  # src/purge_command.sh
  #!/usr/bin/env bash

  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  istatus="$(img_status)"
  pstatus="$(partition_status)"
  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"

  if [[ "${istatus}" = "1" ]] && [[ "${pstatus}" = "0" ]]; then
  	check_root
  	umount_img
  elif [[ "${pstatus}" = "1" ]]; then
  	check_root
  	umount_partitions "${arch_sdcard_img}" "${boot_path}" "${root_path}"
  	umount_img
  fi

  purge_storage "${arch_sdcard_img}" "${istatus}"

}

# :command.function
simonpi_run_command() {
  # src/run_command.sh
  #!/usr/bin/env bash

  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  docker="$(check_docker)"
  istatus="$(img_status)"
  pstatus="$(partition_status)"
  device1=$(sudo -E losetup -f)
  device2=/dev/loop$((${device1##*/loop} + 1))
  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"
  cmd_line=""
  cmd_line_network=""
  custom_image="${args[--path]}"

  # Network Variables
  bridge_if="rasp-br0"
  tap_if="rasp-tap0"
  gateway_ip="192.168.66.1"
  first_ip="${gateway_ip%.1}.2"
  last_ip="${gateway_ip%.1}.254"
  broadcast_ip="${gateway_ip%.1}.255"
  guest_port_1="22"
  external_port_1="2222"
  guest_port_2="80"
  external_port_2="8080"

  check_kernel
  if [[ -n ${custom_image} ]]; then
    run_custom_img "${custom_image}"
    arch_sdcard_img="${custom_image}"
  fi

  if [[ ${istatus} == "0" ]] && [[ ${pstatus} == "0" ]]; then
    check_root
    check_loop_devices "${device2}"
    mount_img "${arch_sdcard_img}" "${device1}" "${device2}"
    check_fs "${device1}" "${device2}"
    check_storage
    mount_partitions "${arch_sdcard_img}" "${device1}" "${device2}" "${boot_path}" "${root_path}"
  elif [[ ${istatus} == "1" ]] && [[ ${pstatus} == "0" ]]; then
    check_root
    check_loop_devices "${device2}"
    check_fs "${device1}" "${device2}"
    check_storage
    mount_partitions "${arch_sdcard_img}" "${device1}" "${device2}" "${boot_path}" "${root_path}"
  fi

  if [[ -n ${args[--path]} ]]; then
    cmd_line=" -initrd ${boot_path}/initramfs-linux.img"
  fi

  if [[ ${docker} == "0" ]]; then
    check_root
    create_network "${tap_if}" "${bridge_if}" "${gateway_ip}" "${broadcast_ip}"
    check_dnsmasq "${gateway_ip}"
    setup_dnsmasq "${gateway_ip}" "${first_ip}" "${last_ip}" "${bridge_if}"
    setup_nat

    if [[ ${args[model]} == "rpi" ]]; then
      cmd_line_network="${cmd_line} -net nic,macaddr=$(generate_mac) -net tap,ifname=${tap_if},script=no,downscript=no"
    else
      cmd_line_network="${cmd_line} -device virtio-net-device,mac=$(generate_mac),netdev=net0 -netdev tap,id=net0,ifname=${tap_if},script=no,downscript=no"
    fi

  else

    if [[ ${args[model]} == "rpi" ]]; then
      cmd_line_network="${cmd_line} -net nic,macaddr=$(generate_mac) -net user,hostfwd=tcp::${external_port_1}-:${guest_port_1},hostfwd=tcp::${external_port_2}-:${guest_port_2}"
    else
      cmd_line_network="${cmd_line} -device virtio-net-device,mac=$(generate_mac),netdev=net0 -netdev user,id=net0,hostfwd=tcp::${external_port_1}-:${guest_port_1},hostfwd=tcp::${external_port_2}-:${guest_port_2}"
    fi

  fi

  # write_pflash_images
  run_"${args[model]}" "${arch_sdcard_img}" "${cmd_line_network}"
  umount_partitions "${arch_sdcard_img}" "${boot_path}" "${root_path}"
  umount_img
  qemu_status="$(check_qemu)"

  if [[ ${docker} == "0" ]] && [[ ${qemu_status} == "0" ]]; then
    dnsmasq_pid=$(check_dnsmasq "${gateway_ip}")
    kill_dnsmasq "${dnsmasq_pid}"
    shutdown_network "${bridge_if}" "${tap_if}"
  fi

}

# :command.function
simonpi_umount_command() {
  # src/umount_command.sh
  #!/usr/bin/env bash

  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"
  istatus="$(img_status)"
  pstatus="$(partition_status)"
  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"

  if [[ ${istatus} == "0" ]] && [[ ${pstatus} == "0" ]]; then
    echo -e "[$(yellow_bold " WARN ")] ${arch_sdcard_img##*/} disk image not mounted"
  elif [[ ${istatus} == "1" ]] && [[ ${pstatus} == "0" ]]; then
    check_root
    umount_img
  elif [[ ${pstatus} == "1" ]]; then
    check_root
    umount_partitions "${arch_sdcard_img}" "${boot_path}" "${root_path}"
    umount_img
  else
    exit 1
  fi

}

# :command.function
simonpi_write_command() {
  # src/write_command.sh
  #!/usr/bin/env bash

  write_sdcard_img() {
    local arch_sdcard_img="${1}"

    if [[ -e ${arch_sdcard_img} ]]; then
      echo -e "[$(yellow_bold " WARN ")] An ${arch_sdcard_img##*/} file already exists. Please delete it"
      exit 1
    else
      echo -e "[$(green_bold "  OK  ")] Creating a ${args[--size]} GB disk image named ${arch_sdcard_img##*/} ..."
      qemu-img create -f raw "${arch_sdcard_img}" "${args[--size]}"G >/dev/null
      echo -e "[$(green_bold "  OK  ")] Creating partition table on ${arch_sdcard_img##*/} ..."
      (
        echo o
        echo n
        echo p
        echo 1
        echo 8192
        echo +100M
        echo t
        echo c
        echo n
        echo p
        echo 2
        echo 8192
        echo
        echo
        echo w
      ) |
        fdisk "${arch_sdcard_img}" >/dev/null 2>&1
    fi
  }

  extract_arch() {
    local arch_iso="${1}"
    local arch_sdcard_img="${2}"
    local boot_path="${3}"
    local root_path="${4}"

    echo -e "[$(green_bold "  OK  ")] Extracting ${arch_iso} to ${arch_sdcard_img##*/} ..."
    sudo bsdtar --exclude=^boot -xpf "${STORAGE}/${args[model]}/${arch_iso}" -C "${root_path}"
    sudo bsdtar -xpf "${STORAGE}/${args[model]}/${arch_iso}" boot/* -C "${boot_path}" >/dev/null 2>&1
  }

  isaNumber='^[0-9]+$'

  if ! [[ ${args[--size]} =~ ${isaNumber} ]] || [[ -z ${args[--size]} ]]; then
    echo -e "[$(red_bold "FAILED")] Please specify a size in GB"
    exit 1
  elif [[ ${args[--size]} -lt 2 ]]; then
    echo -e "[$(red_bold "FAILED")] Please specify a size >= 2 GB"
    exit 1
  fi

  case "${args[model]}" in
  rpi)
    echo -e "[$(red_bold "FAILED")] ARMv5 and ARMv6 architectures are not supported anymore"
    echo -e "[$(cyan_bold " INFO ")] You can still run whatever sdcard image with --path flag"
    exit 1
    ;;
  rpi-2)
    iso_type="rpi-armv7"
    ;;
  *)
    iso_type="rpi-aarch64"
    ;;
  esac

  arch_iso_md5="ArchLinuxARM-${iso_type}-latest.tar.gz.md5"
  arch_sdcard_img="${STORAGE}/sd-arch-${args[model]}-qemu.img"

  boot_path="${STORAGE}/${args[model]}/boot"
  root_path="${STORAGE}/${args[model]}/root"

  device1=$(sudo -E losetup -f)
  device2=/dev/loop$((${device1##*/loop} + 1))

  check_storage
  download_arch_image "${arch_iso_md5}"
  integrity_check "${arch_iso_md5}"
  partition_status
  img_status
  write_sdcard_img "${arch_sdcard_img}"
  sync
  check_root
  mount_img "${arch_sdcard_img}" "${device1}" "${device2}"
  check_loop_devices "${device2}"
  format_lo_devices "${arch_sdcard_img}" "${device1}" "${device2}"
  sync
  mount_partitions "${arch_sdcard_img}" "${device1}" "${device2}" "${boot_path}" "${root_path}"
  extract_arch "${arch_iso_md5%%.md5}" "${arch_sdcard_img}" "${boot_path}" "${root_path}"
  # customContent
  sync
  umount_partitions "${arch_sdcard_img}" "${boot_path}" "${root_path}"
  umount_img
  sudo chown "${USER}:${USER}" "${arch_sdcard_img}"
  echo -e "[$(green_bold "  OK  ")] DONE"

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        simonpi_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter
  # :command.environment_variables_default
  export STORAGE="${STORAGE:-${HOME}/.simonpi}"
  export KERNEL_PATH="${KERNEL_PATH:-./data/kernels}"

  if [[ -z "${STORAGE:-}" ]]; then
    printf "missing required environment variable: STORAGE\n" >&2
    exit 1
  fi
  if [[ -z "${KERNEL_PATH:-}" ]]; then
    printf "missing required environment variable: KERNEL_PATH\n" >&2
    exit 1
  fi

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    completions)
      action="completions"
      shift
      simonpi_completions_parse_requirements "$@"
      shift $#
      ;;

    check)
      action="check"
      shift
      simonpi_check_parse_requirements "$@"
      shift $#
      ;;

    epurge)
      action="epurge"
      shift
      simonpi_epurge_parse_requirements "$@"
      shift $#
      ;;

    kernel)
      action="kernel"
      shift
      simonpi_kernel_parse_requirements "$@"
      shift $#
      ;;

    kill)
      action="kill"
      shift
      simonpi_kill_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      simonpi_list_parse_requirements "$@"
      shift $#
      ;;

    mount)
      action="mount"
      shift
      simonpi_mount_parse_requirements "$@"
      shift $#
      ;;

    purge)
      action="purge"
      shift
      simonpi_purge_parse_requirements "$@"
      shift $#
      ;;

    run)
      action="run"
      shift
      simonpi_run_parse_requirements "$@"
      shift $#
      ;;

    umount)
      action="umount"
      shift
      simonpi_umount_parse_requirements "$@"
      shift $#
      ;;

    write)
      action="write"
      shift
      simonpi_write_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      simonpi_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
simonpi_completions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_completions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="completions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
simonpi_check_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_check_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="check"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi check MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_epurge_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_epurge_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="epurge"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi epurge MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_kernel_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_kernel_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kernel"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi kernel MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_kill_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_kill_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="kill"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi kill MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi list MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_mount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_mount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="mount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi mount MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_purge_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_purge_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="purge"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi purge MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_run_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_run_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="run"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --path)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--path']="$2"
          shift
          shift
        else
          printf "%s\n" "--path requires an argument: --path PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi run MODEL [OPTIONS]\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_umount_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_umount_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="umount"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi umount MODEL\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
simonpi_write_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    case "${1:-}" in
      --help | -h)
        long_usage=yes
        simonpi_write_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="write"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --size | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then

          args['--size']="$2"
          shift
          shift
        else
          printf "%s\n" "--size requires an argument: --size, -s SIZE" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        if [[ -z ${args['model']+x} ]]; then

          args['model']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['model']+x} ]]; then
    printf "missing required argument: MODEL\nusage: simonpi write MODEL [OPTIONS]\n" >&2
    exit 1
  fi

  # :command.required_flags_filter
  if [[ -z ${args['--size']+x} ]]; then
    printf "missing required flag: --size, -s SIZE\n" >&2
    exit 1
  fi

}

# :command.initialize
initialize() {
  version="2.0.0"
  long_usage=''
  set -e

  # :command.environment_variables_default
  export STORAGE="${STORAGE:-${HOME}/.simonpi}"
  export KERNEL_PATH="${KERNEL_PATH:-./data/kernels}"

  # src/initialize.sh
  #!/usr/bin/env bash


}

# :command.run
run() {
  declare -A args=()
  declare -a other_args=()
  declare -a input=()
  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "completions")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_completions_usage
      else
        simonpi_completions_command
      fi
      ;;

    "check")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_check_usage
      else
        simonpi_check_command
      fi
      ;;

    "epurge")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_epurge_usage
      else
        simonpi_epurge_command
      fi
      ;;

    "kernel")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_kernel_usage
      else
        simonpi_kernel_command
      fi
      ;;

    "kill")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_kill_usage
      else
        simonpi_kill_command
      fi
      ;;

    "list")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_list_usage
      else
        simonpi_list_command
      fi
      ;;

    "mount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_mount_usage
      else
        simonpi_mount_command
      fi
      ;;

    "purge")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_purge_usage
      else
        simonpi_purge_command
      fi
      ;;

    "run")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_run_usage
      else
        simonpi_run_command
      fi
      ;;

    "umount")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_umount_usage
      else
        simonpi_umount_command
      fi
      ;;

    "write")
      if [[ ${args['--help']:-} ]]; then
        long_usage=yes
        simonpi_write_usage
      else
        simonpi_write_command
      fi
      ;;

  esac
}

initialize
run "$@"
